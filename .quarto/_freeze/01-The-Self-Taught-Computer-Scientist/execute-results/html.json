{
  "hash": "c6784ed67509e0a2fabc3e0270c6d30f",
  "result": {
    "markdown": "---\ntitle: \"Self-Taught-CS\"\ndate: \"2022-10-22\"\n---\n\n# Algorithms\n\n## Recursion\n\nAn iterative algorithm that calculates the factorial of a number, `n`:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ndef factorical(n):\n  the_product = 1\n  while n > 0:\n    the_product *= n\n    n = n - 1\n  return the_product\n\nfactorical(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\n120\n```\n:::\n:::\n\n\nHow to write the same algorithm recursively:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ndef factorical(n):\n  if n == 0:\n    return 1\n  return n * factorical(n - 1)\n\nfactorical(5)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n120\n```\n:::\n:::\n\n\n## Search Algorithms\n\n### Linear Search\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndef linear_search(a_list, n):\n  for i in a_list:\n    if i == n:\n      return True\n  return False\n\na_list = [1, 8, 32, 91, 5, 15, 9, 100, 3]\nlinear_search(a_list, 91)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nTrue\n```\n:::\n:::\n\n\nA linear search's time complexity is $O(n)$. You should consider using a linear search when your data is not sorted.\n\nUsing Python's `in` keyword, you performed a linear search on `unsorted_list` in just one line of code:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nunsorted_list = [1, 45, 4, 32, 3]\nprint(45 in unsorted_list)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint(\"a\" in \"apple\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\n```\n:::\n:::\n\n\n## Binary Search\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef binary_search(a_list, n):\n  first = 0\n  last = len(a_list) - 1\n  while last >= first:\n    mid = (first + last) // 2\n    if a_list[mid] == n:\n      return True\n    else:\n      if n < a_list[mid]:\n        last = mid - 1\n      else:\n        first = mid + 1\n  return False\n\na_list = [1, 3, 5, 8, 9, 91, 100]\nbinary_search(a_list, 91)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nTrue\n```\n:::\n:::\n\n\nA binary search takes $O(\\log n)$ time. It is more efficient than a linear search because you don't have to search an entire list. Because of how efficient a binary search is, if you have sorted data you need to search, it is usually best to use one. However, even if you have unsorted data, sometimes it is worth sorting it to take advantage of binary search.\n\nThe key to writing a binary search using Python's built-in tools is to use `bisect_left` from the `bisect` module, which finds the index of an existing element in a sorted list using binary search:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nfrom bisect import bisect_left\n\nsorted_fruits = [\"apple\", \"banana\", \"orange\", \"plum\"]\nbisect_left(sorted_fruits, \"banana\")\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n1\n```\n:::\n:::\n\n\n",
    "supporting": [
      "01-The-Self-Taught-Computer-Scientist_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}